"local_opts" = local_opts)
res <- nloptr(
x0 = x0,
eval_f = eval_1,
eval_g_eq = eval_g_eq,
lb = lb,
ub = ub,
opts = opts
)
return(c(res$solution, p_2, q_1))
}
d_firm_1_lin(0.2,0.2)
d_firm_1_lin <- function(w_A, w_B) {
w = w_A
# Bertrand game
p_1 = (1 + w) / (2 - k) # constant marginal cost, assuming w_A = w_B
p_2 = (1 + w) / (2 - k)
q_1 = 1 - p_1 + k * p_2     # Differentiated product Bertrand, substitution param = 0.5
# model input demand
# assume production function is q = x_1 + x_2
eval_1 <- function(x) {
return(list(
"objective" = -(p_1 * (x[1] + x[2]) - w * (x[1] + x[2])),
"gradient" = c(-p_1 + w,-p_1 + w)
))
}
eval_g_eq <- function(x) {
constr <- c(x[1] + x[2] - q_1)
grad <- c(1,1)
return(list("constraints" = constr, "jacobian" = grad))
}
#initial values
x0 <- c(0, 0)
lb <- c(0, 0)
ub <- c(1, 1)
local_opts <- list( "algorithm" = "NLOPT_LD_MMA",
"xtol_rel"  = 1.0e-7 )
opts <- list("algorithm" = "NLOPT_LD_AUGLAG",
"xtol_rel" = 1.0e-7,
"local_opts" = local_opts)
res <- nloptr(
x0 = x0,
eval_f = eval_1,
eval_g_eq = eval_g_eq,
lb = lb,
ub = ub,
opts = opts
)
pi = res$objective
return(c(res$solution, p_2, q_1, pi))
}
d_firm_1_lin(0.2,0.2)
# Linear production
k = 0.5
d_firm_1_lin <- function(w_A, w_B) {
w = w_A
# Bertrand game
p_1 = (1 + w) / (2 - k) # constant marginal cost, assuming w_A = w_B
p_2 = (1 + w) / (2 - k)
q_1 = 1 - p_1 + k * p_2     # Differentiated product Bertrand, substitution param = 0.5
# model input demand
# assume production function is q = x_1 + x_2
eval_1 <- function(x) {
return(list(
"objective" = -(p_1 * (x[1] + x[2]) - w * (x[1] + x[2])),
"gradient" = c(-p_1 + w,-p_1 + w)
))
}
eval_g_eq <- function(x) {
constr <- c(x[1] + x[2] - q_1)
grad <- c(1,1)
return(list("constraints" = constr, "jacobian" = grad))
}
#initial values
x0 <- c(0, 0)
lb <- c(0, 0)
ub <- c(1, 1)
local_opts <- list( "algorithm" = "NLOPT_LD_MMA",
"xtol_rel"  = 1.0e-7 )
opts <- list("algorithm" = "NLOPT_LD_AUGLAG",
"xtol_rel" = 1.0e-7,
"local_opts" = local_opts)
res <- nloptr(
x0 = x0,
eval_f = eval_1,
eval_g_eq = eval_g_eq,
lb = lb,
ub = ub,
opts = opts
)
pi = -(res$objective)  #profit is negative of obj value because optim mins
return(c(res$solution, p_2, q_1, pi))
}
d_firm_1_lin(0.2,0.2)
# Linear production
k = 0.8
d_firm_1_lin <- function(w_A, w_B) {
w = w_A
# Bertrand game
p_1 = (1 + w) / (2 - k) # constant marginal cost, assuming w_A = w_B
p_2 = (1 + w) / (2 - k)
q_1 = 1 - p_1 + k * p_2     # Differentiated product Bertrand, substitution param = 0.5
# model input demand
# assume production function is q = x_1 + x_2
eval_1 <- function(x) {
return(list(
"objective" = -(p_1 * (x[1] + x[2]) - w * (x[1] + x[2])),
"gradient" = c(-p_1 + w,-p_1 + w)
))
}
eval_g_eq <- function(x) {
constr <- c(x[1] + x[2] - q_1)
grad <- c(1,1)
return(list("constraints" = constr, "jacobian" = grad))
}
#initial values
x0 <- c(0, 0)
lb <- c(0, 0)
ub <- c(1, 1)
local_opts <- list( "algorithm" = "NLOPT_LD_MMA",
"xtol_rel"  = 1.0e-7 )
opts <- list("algorithm" = "NLOPT_LD_AUGLAG",
"xtol_rel" = 1.0e-7,
"local_opts" = local_opts)
res <- nloptr(
x0 = x0,
eval_f = eval_1,
eval_g_eq = eval_g_eq,
lb = lb,
ub = ub,
opts = opts
)
pi = -(res$objective)  #profit is negative of obj value because optim mins
return(c(res$solution, p_2, q_1, pi))
}
d_firm_1_lin(0.2,0.2)
# Linear production
k = 0.1
d_firm_1_lin <- function(w_A, w_B) {
w = w_A
# Bertrand game
p_1 = (1 + w) / (2 - k) # constant marginal cost, assuming w_A = w_B
p_2 = (1 + w) / (2 - k)
q_1 = 1 - p_1 + k * p_2     # Differentiated product Bertrand, substitution param = 0.5
# model input demand
# assume production function is q = x_1 + x_2
eval_1 <- function(x) {
return(list(
"objective" = -(p_1 * (x[1] + x[2]) - w * (x[1] + x[2])),
"gradient" = c(-p_1 + w,-p_1 + w)
))
}
eval_g_eq <- function(x) {
constr <- c(x[1] + x[2] - q_1)
grad <- c(1,1)
return(list("constraints" = constr, "jacobian" = grad))
}
#initial values
x0 <- c(0, 0)
lb <- c(0, 0)
ub <- c(1, 1)
local_opts <- list( "algorithm" = "NLOPT_LD_MMA",
"xtol_rel"  = 1.0e-7 )
opts <- list("algorithm" = "NLOPT_LD_AUGLAG",
"xtol_rel" = 1.0e-7,
"local_opts" = local_opts)
res <- nloptr(
x0 = x0,
eval_f = eval_1,
eval_g_eq = eval_g_eq,
lb = lb,
ub = ub,
opts = opts
)
pi = -(res$objective)  #profit is negative of obj value because optim mins
return(c(res$solution, p_2, q_1, pi))
}
d_firm_1_lin(0.2,0.2)
# Linear production
k = 0.2
d_firm_1_lin <- function(w_A, w_B) {
w = w_A
# Bertrand game
p_1 = (1 + w) / (2 - k) # constant marginal cost, assuming w_A = w_B
p_2 = (1 + w) / (2 - k)
q_1 = 1 - p_1 + k * p_2     # Differentiated product Bertrand, substitution param = 0.5
# model input demand
# assume production function is q = x_1 + x_2
eval_1 <- function(x) {
return(list(
"objective" = -(p_1 * (x[1] + x[2]) - w * (x[1] + x[2])),
"gradient" = c(-p_1 + w,-p_1 + w)
))
}
eval_g_eq <- function(x) {
constr <- c(x[1] + x[2] - q_1)
grad <- c(1,1)
return(list("constraints" = constr, "jacobian" = grad))
}
#initial values
x0 <- c(0, 0)
lb <- c(0, 0)
ub <- c(1, 1)
local_opts <- list( "algorithm" = "NLOPT_LD_MMA",
"xtol_rel"  = 1.0e-7 )
opts <- list("algorithm" = "NLOPT_LD_AUGLAG",
"xtol_rel" = 1.0e-7,
"local_opts" = local_opts)
res <- nloptr(
x0 = x0,
eval_f = eval_1,
eval_g_eq = eval_g_eq,
lb = lb,
ub = ub,
opts = opts
)
pi = -(res$objective)  #profit is negative of obj value because optim mins
return(c(res$solution, p_2, q_1, pi))
}
d_firm_1_lin(0.2,0.2)
# Linear production
k = 0.3 # amount captured if other firm raises price by $1
d_firm_1_lin <- function(w_A, w_B) {
w = w_A
# Bertrand game
p_1 = (1 + w) / (2 - k) # constant marginal cost, assuming w_A = w_B
p_2 = (1 + w) / (2 - k)
q_1 = 1 - p_1 + k * p_2     # Differentiated product Bertrand, substitution param = 0.5
# model input demand
# assume production function is q = x_1 + x_2
eval_1 <- function(x) {
return(list(
"objective" = -(p_1 * (x[1] + x[2]) - w * (x[1] + x[2])),
"gradient" = c(-p_1 + w,-p_1 + w)
))
}
eval_g_eq <- function(x) {
constr <- c(x[1] + x[2] - q_1)
grad <- c(1,1)
return(list("constraints" = constr, "jacobian" = grad))
}
#initial values
x0 <- c(0, 0)
lb <- c(0, 0)
ub <- c(1, 1)
local_opts <- list( "algorithm" = "NLOPT_LD_MMA",
"xtol_rel"  = 1.0e-7 )
opts <- list("algorithm" = "NLOPT_LD_AUGLAG",
"xtol_rel" = 1.0e-7,
"local_opts" = local_opts)
res <- nloptr(
x0 = x0,
eval_f = eval_1,
eval_g_eq = eval_g_eq,
lb = lb,
ub = ub,
opts = opts
)
pi = -(res$objective)  #profit is negative of obj value because optim mins
return(c(res$solution, p_2, q_1, pi))
}
d_firm_1_lin(0.2,0.2)
d_firm_1_lin(0.4,0.4)
d_firm_1_lin(0.8,0.8)
# Linear production
k = 0.4 # amount captured if other firm raises price by $1
d_firm_1_lin <- function(w_A, w_B) {
w = w_A
# Bertrand game
p_1 = (1 + w) / (2 - k) # constant marginal cost, assuming w_A = w_B
p_2 = (1 + w) / (2 - k)
q_1 = 1 - p_1 + k * p_2     # Differentiated product Bertrand, substitution param = 0.5
# model input demand
# assume production function is q = x_1 + x_2
eval_1 <- function(x) {
return(list(
"objective" = -(p_1 * (x[1] + x[2]) - w * (x[1] + x[2])),
"gradient" = c(-p_1 + w,-p_1 + w)
))
}
eval_g_eq <- function(x) {
constr <- c(x[1] + x[2] - q_1)
grad <- c(1,1)
return(list("constraints" = constr, "jacobian" = grad))
}
#initial values
x0 <- c(0, 0)
# upper and lower bounds
lb <- c(0, 0)
ub <- c(1, 1)
# optimize
local_opts <- list( "algorithm" = "NLOPT_LD_MMA",
"xtol_rel"  = 1.0e-7 )
opts <- list("algorithm" = "NLOPT_LD_AUGLAG",
"xtol_rel" = 1.0e-7,
"local_opts" = local_opts)
res <- nloptr(
x0 = x0,
eval_f = eval_1,
eval_g_eq = eval_g_eq,
lb = lb,
ub = ub,
opts = opts
)
pi = -(res$objective)  #profit is negative of obj value because optim mins
return(c(res$solution, p_2, q_1, pi))
}
d_firm_1_lin(0.8,0.8)
d_firm_1 <- function(w_1, w_2){
# observe following demand curve: Q = a - b1p1 + b2p2;  b1 > b2
a <- 1
b1 <- 1
b2 <- .5
# firm's production function: (x1x2)^0.5
c <- 2(w_1*w_2)^0.5  # marginal cost
# diff prod. bertrand
p <- (a + c * b1)/(2 * b1 - b2)
q <- b1*(a + c*(b2 - b1))/(2*b1 - b2)
# profit function
pi <- p * q - 2*q*(w_1*w_2)^0.5
return(-pi)
}
out <- optim(c(0.5, 0.5), d_firm_1)
d_firm_1 <- function(w_1, w_2){
# observe following demand curve: Q = a - b1p1 + b2p2;  b1 > b2
a <- 1
b1 <- 1
b2 <- .5
# firm's production function: (x1x2)^0.5
c <- 2*(w_1*w_2)^0.5  # marginal cost
# diff prod. bertrand
p <- (a + c * b1)/(2 * b1 - b2)
q <- b1*(a + c*(b2 - b1))/(2*b1 - b2)
# profit function
pi <- p * q - 2*q*(w_1*w_2)^0.5
return(-pi)
}
out <- optim(c(0.5, 0.5), d_firm_1)
d_firm_1(0.5,0.5)
d_firm_1(0.2,0.5)
d_firm_1(0.2,0.2)
d_firm_1(0,0)
d_firm_1(1,1)
d_firm_1(0.6,0.6)
out <- optim(c(0.4,0.4), d_firm_1)
d_firm_1 <- function(w){
# observe following demand curve: Q = a - b1p1 + b2p2;  b1 > b2
w_1 = w[1]
w_2 = w[2]
a <- 1
b1 <- 1
b2 <- .5
# firm's production function: (x1x2)^0.5
c <- 2*(w_1*w_2)^0.5  # marginal cost
# diff prod. bertrand
p <- (a + c * b1)/(2 * b1 - b2)
q <- b1*(a + c*(b2 - b1))/(2*b1 - b2)
# profit function
pi <- p * q - 2*q*(w_1*w_2)^0.5
return(-pi)
}
out <- optim(c(0.4,0.4), d_firm_1)
d_firm_1 <- function(w){
# observe following demand curve: Q = a - b1p1 + b2p2;  b1 > b2
w_1 = w[1]
w_2 = w[2]
a <- 1
b1 <- 1
b2 <- .5
# firm's production function: (x1x2)^0.5
c <- 2*(w_1*w_2)^0.5  # marginal cost
# diff prod. bertrand
p <- (a + c * b1)/(2 * b1 - b2)
q <- b1*(a + c*(b2 - b1))/(2*b1 - b2)
# profit function
pi <- p * q - 2*q*(w_1*w_2)^0.5
return(-pi)
}
out <- optim(c(0.4,0.4), d_firm_1)
out
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/scratch.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/scratch.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/scratch.R', echo=TRUE)
d_firm_1(c(0.2,0.2))
d_firm_1(c(0.25, 0.5))
d_firm_1(c(0.4, 0.4))
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
u_firm(c(eq_int_good$w_1A, eq_int_good$w_2A), c(eq_int_good$w_1B, eq_int_good$w_2B), M)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
iter = 0
out_tol = 1
optim_A = 0
# while (out_tol > 1E-9) {
iter = iter + 1  # count iterations
optim_A = 1 - optim_A  # optimizing which upstream firm's offer
pi_A_old <- eq_pi$pi_A # keeping tabs on old profits
pi_B_old <- eq_pi$pi_B
# optimize firm A given firm B prices are fixed
if (optim_A == 1) {
firm_A_optim <-
optim(
par = c(eq_int_good$w_1A, eq_int_good$w_2A),
fn = u_firm,
w_B = c(eq_int_good$w_1B, eq_int_good$w_2B),
M = M,
method = "Nelder-Mead",
control = list(maxit = 10000, reltol = 1E-12)
)
out_tol = abs(sqrt(eq_pi$pi_A ^ 2 + eq_pi$pi_B ^ 2) - sqrt(pi_A_old ^ 2 + pi_B_old ^
2))
} else {
firm_B_optim <-
optim(
par = c(eq_int_good$w_1B, eq_int_good$w_2B),
fn = u_firm,
w_A = c(eq_int_good$w_1A, eq_int_good$w_2A),
M = M,
method = "Nelder-Mead",
control = list(maxit = 10000, reltol = 1E-12)
)
out_tol = abs(sqrt(eq_pi$pi_A^2 + eq_pi$pi_B^2) - sqrt(pi_A_old^2 + pi_B_old^2))
}
View(eq)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
iter = 0
out_tol = 1
optim_A = 0
# while (out_tol > 1E-9) {
iter = iter + 1  # count iterations
optim_A = 1 - optim_A  # optimizing which upstream firm's offer
pi_A_old <- eq_pi$pi_A # keeping tabs on old profits
pi_B_old <- eq_pi$pi_B
# optimize firm A given firm B prices are fixed
if (optim_A == 1) {
firm_A_optim <-
optim(
par = c(eq_int_good$w_1A, eq_int_good$w_2A),
fn = u_firm,
w_B = c(eq_int_good$w_1B, eq_int_good$w_2B),
M = M,
method = "Nelder-Mead",
control = list(maxit = 10000, reltol = 1E-12)
)
out_tol = abs(sqrt(eq_pi$pi_A ^ 2 + eq_pi$pi_B ^ 2) - sqrt(pi_A_old ^ 2 + pi_B_old ^
2))
} else {
firm_B_optim <-
optim(
par = c(eq_int_good$w_1B, eq_int_good$w_2B),
fn = u_firm,
w_A = c(eq_int_good$w_1A, eq_int_good$w_2A),
M = M,
method = "Nelder-Mead",
control = list(maxit = 10000, reltol = 1E-12)
)
out_tol = abs(sqrt(eq_pi$pi_A^2 + eq_pi$pi_B^2) - sqrt(pi_A_old^2 + pi_B_old^2))
}
firm_A_optim
# optimize firm A given firm B prices are fixed
if (optim_A == 1) {
firm_A_optim <-
optim(
par = c(eq_int_good$w_1A, eq_int_good$w_2A),
fn = u_firm,
w_B = c(eq_int_good$w_1B, eq_int_good$w_2B),
M = M,
method = "Nelder-Mead",
control = list(maxit = 10000, reltol = 1E-12)
)
out_tol = abs(sqrt(eq_pi$pi_A ^ 2 + eq_pi$pi_B ^ 2) - sqrt(pi_A_old ^ 2 + pi_B_old ^
2))
} else {
firm_B_optim <-
optim(
par = c(eq_int_good$w_1B, eq_int_good$w_2B),
fn = u_firm,
w_A = c(eq_int_good$w_1A, eq_int_good$w_2A),
M = M,
method = "Nelder-Mead",
control = list(maxit = 10000, reltol = 1E-12)
)
out_tol = abs(sqrt(eq_pi$pi_A^2 + eq_pi$pi_B^2) - sqrt(pi_A_old^2 + pi_B_old^2))
}
firm_A_optim
out_tol = abs(sqrt(eq_pi$pi_A ^ 2 + eq_pi$pi_B ^ 2) - sqrt(pi_A_old ^ 2 + pi_B_old ^
2))
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
firm_B_optim
firm_A_optim
u_firm(c(eq_int_good$w_1A, eq_int_good$w_2A), c(eq_int_good$w_1B, eq_int_good$w_2B), M)
u_firm(c(eq_int_good$w_1A + 0.01, eq_int_good$w_2A), c(eq_int_good$w_1B, eq_int_good$w_2B), M)
u_firm(c(eq_int_good$w_1A + 0.2, eq_int_good$w_2A), c(eq_int_good$w_1B, eq_int_good$w_2B), M)
u_firm(c(eq_int_good$w_1A, eq_int_good$w_2A), c(eq_int_good$w_1B + 0.02, eq_int_good$w_2B), M)
u_firm(c(eq_int_good$w_1A, eq_int_good$w_2A), c(eq_int_good$w_1B + 0.01, eq_int_good$w_2B), M)
u_firm(c(eq_int_good$w_1A, eq_int_good$w_2A), c(eq_int_good$w_1B, eq_int_good$w_2B + 0.01), M)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
source('G:/My Drive/Ivan/College/2018-2019/Indep Study/R Code/main_test.R', echo=TRUE)
